# -*- coding: utf-8 -*-
"""code_notebook_cosc526_Answer.S.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Kp-HXxbpljzYfzH9kWEWwVEe23Z6q8Mp

# **`M.0.Overview of codebook, answers, instructions, and libraries`**

## **`I. how.To use course codebook`**  
1. Notebook works in both Jupyter Notebooks & Colab.  
2. Google built [colab](https://colab.research.google.com/) on top of Notebooks to add more features.  
3. Cosc.526 was configured in Colab with expand/collapse sectioning.  
4. There are 9 parent sections for each course module.  
5. Modules contain either exercise and assignment or both.  
6. **ALL** additional links and resources are to quality resources and tools.  
=> Consider bookmarking them for future analysis activities!  
7. Your going to be "coding." Consider flipping a monitor vertically to help code.    
8. A minimum of two monitors is recommended.   
9. Try opening same workbook in multiple screens to perform work.  
10. **p.s.** colab offer on screen companions like corgis and crabs.  

## **`II. What is an answer?`**  
- Answers are outcomes generated from executing your solution's code.  
- ***What if your homework code isn't running?***  
- Add one textbox beneath code block ***Enter solution here***  
- Succinctly explain work performed (for grading points).  

## **`III. Umbrella instructions`**  
1. ### **`Solve exercise and assignment tasks by`**  
a. writing code.  
b. modifying code provided.  
c. answering specified questions concisely.     

2. ### **`Submit requirements`**  
d. upload a **.pdf** copy after renaming it to...    
e. => modules 1-2: last.first.exercise.and.assignment.M.#.pdf  
f. => modules 3-9: last.first.assignment.M.#.pdf  

3. ### **`How to generate a .pdf for submitting homework`**
g. Jupyter Notebook has File\Save As\ adobe.pdf  
h. **What do you do if .pdf generation fails?**  
i. option.1) when in doubt, always submit a **.ipynb** file!  
j. option.2) inform the professor and request permission to submit **.ipynb**   
k. option.3) research and fix; Youtube and [Jupyter.forum](https://discourse.jupyter.org/).

4. ### **`What are Expected outcomes?`**  
l. Answer: A solution to a provided task.  
m. They're regularly provided, but only sometimes.  
n. They're located directly beneath **Enter solution here**

5. ### **`How many code blocks should an output answer be?`**    
o. Whenever feasible, combine answers into one codeblock. Brevity is key!  

## **`IV. cosc.526 Python required libraries`**  
1. Run the following library code "now"; ensure all are installed.  
2. If not, research and solve it straight away! [Jupyter.forum](https://discourse.jupyter.org/)  
3. **Why?** Errors occur for many reasons, like old versions and wrong pip files.  
3. **Need help?** research libraries at => [pypi.org](https://pypi.org/)   
  

## **`V. Additional resources`**    
1. Built for this course; healhty compendium of essential Python coding  
2. [Python reference.library.Cosc.526.pdf](https://github.com/cosc-526/cosc.526.home.page/blob/main/reference.library.COSC.526.pdf)    
3. [Python Docs](https://docs.python.org/3/) remain **`simply the best`**  
4. We love and miss you [TinaTurner!](https://www.youtube.com/watch?v=GC5E8ie2pdM)
"""

#=>update all installed libraries at one time; run in terminal
#=> courtesy snhu.edu undergrad RyanB
"""
python3 -m pip list --outdated --format=json | jq -r '.[] | "\(.name)==\(.latest_version)"' | xargs -n1 pip3 install -U
"""

#Run to see if libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly                #SVM hyperplane graphing
import plotly.express as px  #SVM hyperplane graphing
#!pip install pyspark
from pyspark.sql import SparkSession #typically requires a pip install

print("all libraries are installed! You are ready to code")
print("------- \n")

!pip show ipython      #confirms library installed
#!pip install ipython  #installs a library in Notebook or Colab

"""# **`M.1.Introduction to data mining`**

## **`exercise.M.1`** - Python Warmup

### **`Overview and Directions`**

* Practice importing and parsing information. 
* Focus on learning and solving versus coding perfectly.  
* Perform tasks without assistance from clever sources.  

#### **`Desired outcomes`**  
- Experience open, read, and writing of external delimited files.  
- Navigate basic text mining preprocessing like white space stripping.  
- Refresh expereience with iterator, conditionals, and functions.  

####**`Additional Resources`**  
- course [Python reference.library.Cosc.526.pdf](https://github.com/cosc-526/cosc.526.home.page/blob/main/reference.library.COSC.526.pdf)  
=> contains a deep and wide index of essential Python coding.  
- Bookmark the masters of text preprocessing  
=> [Jurafsky and Martin, Speech and Language Processing](https://web.stanford.edu/~jurafsky/slp3/)  
=> additional quality textbook on classical text mining  
=> [Wiess,S.,Indurkhya,N.,Zhang,T.,(2015), Fundamentals of predictive text mining, 2nd, Springer.](https://www.amazon.com/Fundamentals-Predictive-Mining-Computer-Science/dp/144716749X/ref=sr_1_1?crid=MUA7UG21IFPD&keywords=Wiess%2CS.%2CIndurkhya%2CN.%2CZhang%2CT.%2C%282015%29%2C+Fundamentals+of+predictive+text+mining%2C+2nd%2C+Springer&qid=1685151591&sprefix=wiess%2Cs.%2Cindurkhya%2Cn.%2Czhang%2Ct.%2C+2015+%2C+fundamentals+of+predictive+text+mining%2C+2nd%2C+springer%2Caps%2C78&sr=8-1)

### **`Task.1`**  - comma-separated values (.csv)

Reading and parsing [delimiter-separated values](https://en.wikipedia.org/wiki/Delimiter-separated_values) files like [comma-separated](https://en.wikipedia.org/wiki/Comma-separated_values) and [tab-separated values](https://en.wikipedia.org/wiki/Tab-separated_values) is a regular data science preprocessing activity. It is typically acceptable to request either file format for analysis activities.    
- *.csv* files store tabular data like numbers and text in a plain text format. 
- Plain text may include text, white spaces, carriage returns, transliterals, and other artifacts.    
- Each row, or data record, contains a value or nothing, and a comma separates each.    

**Tasks**  
0. [data.exercise.M.1.csv](https://github.com/cosc-526/cosc.526.home.page/blob/main/data.exercise.M.1.csv) => Nobel prize winners name and age     
1. Generate a single value for the total number of rows of data.
2. Generate a single value for the total number of columns of data.  
3. Calculate the laureates average age as a datatype float.  
4. **note:** the solution's answer is structured as a user-defined function (def).  
5. A def is not required, it contains extra code to use throughout the course.  
6. Recall, whenever feasible, combine answers into a single outcome code block.     

**Useful links**  
- [Ch.16, Importing Data, Python.Crash.Course, Matthes](https://github.com/cosc-526/cosc.526.home.page/blob/main/textbook.Python.crash.course.matthes.pdf)  
[open](https://docs.python.org/3.6/library/functions.html#open), 
[readlines](https://docs.python.org/3.6/library/codecs.html#codecs.StreamReader.readlines), [rstrip](https://docs.python.org/3.6/library/stdtypes.html#str.rstrip), [list comprehension](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions), [split](https://docs.python.org/3.6/library/stdtypes.html#str.split), [splice](https://docs.python.org/3.6/glossary.html#term-slice), ["list.love"](https://docs.python.org/3.6/tutorial/datastructures.html#more-on-lists), [len](https://docs.python.org/3.6/library/functions.html#len), [int](https://docs.python.org/3.6/library/functions.html#int), [format](https://docs.python.org/3.6/library/stdtypes.html#str.format)
"""

#=>Enter Your Solution

"""**Task.1 Expected Ouput**
```
Number of rows of data: 8
Number of cols: 3
Average Age: 70.875
```

#### **`Task.1.solution`**
"""

#Task.1 solution
def parse_delimited_file(filename, delimiter=","):
    # Open and read in all lines of the file
    # (I do not recommend readlines for LARGE files)
    # `open`: ref [1]
    # `readlines`: ref [2]
    with open(filename, 'r', encoding='utf8') as dsvfile:
        lines = dsvfile.readlines()

    # Strip off the newline from the end of each line
    # HINT: ref [3]
    # Using list comprehension is the recommended pythonic way to iterate through lists
    # HINT: ref [4]
    lines = [line.rstrip('\n') for line in lines]
    
    # Split each line based on the delimiter (which, in this case, is the comma)
    # HINT: ref [5]
    split_lines = [line.split(delimiter) for line in lines]
    
    # Separate the header from the data
    # HINT: ref [6]
    header = split_lines[0]
    data_lines = split_lines[1:]
    
    # Find "age" within the header
    # (i.e., calculating the column index for "age")
    # HINT: ref [7]
    age_index = header.index("age")

    # Calculate the number of data rows and columns
    # HINT: [8]
    num_data_rows = len(data_lines)
    num_data_cols = len(header)
    
    # Sum the "age" values
    # HINT: ref [9]
    sum_age = 0
    for row in data_lines:
        sum_age += int(row[age_index])
        
    # Calculate the average age
    avg_age = sum_age / num_data_rows
    
    # Print the results
    # `format`: ref [10]
    print("Number of rows of data: {}".format(num_data_rows))
    print("Number of cols: {}".format(num_data_cols))
    print("Average Age: {}".format(avg_age))

#Task.1 solution
parse_delimited_file('data.exercise.M.1.csv')

"""### **`Task.2`** - tab-separated values (.tsv)

A [tab-separated value (.tsv)](https://en.wikipedia.org/wiki/Tab-separated_values) format is a delimiter-separated value for storing data in a tabular structure like a database table or spreadsheet. Other characteristics include,    
- Used to exchange information between databases.
- Each record in the table is one line of the text file.
- Fields are distinct in a record when separated by the tab character **`\t`**

**Tasks**
0. [data.exercise.M.1.tsv](https://github.com/cosc-526/cosc.526.home.page/blob/main/data.exercise.M.1.tsv) 
1. Repeat Task.1 using the .tsv file.  
2. The order and data in columns have changed.  
3. If you hardcoded the "age" column, research and describe alternative code to alleviate fixed positional indexes.  

**Useful links**  
- [Python docs - csv file reading and writing](https://docs.python.org/3/library/csv.html#module-csv) 
- Python handles .tsv files using its "delimiter" parameter, "\t"
"""

#=>Enter Your Solution

"""**Expected Ouput:**
```
Number of rows of data: 11
Number of cols: 3
Average Age: 62.09090909090909
```

#### **`Task.2.solution`**
"""

#task.2.solution
#running the same user.defined.function, but using the delimiter parameter
parse_delimited_file('data.exercise.M.1.tsv', delimiter='\t')

"""### **`Task.3`** - Convert diacritics (ä, ö) to ASCII

- On your computer, right click an open `data.exercise.M.1.csv` in Notepad.  
Observe the Unicode non-English letters in laureates' names like "Schrödinger."
- Learn about [Unicode](https://en.wikipedia.org/wiki/Unicode) character standards for representing different types and forms of text.  
- Grok that Python 3 [natively supports](https://docs.python.org/3/howto/unicode.html) Unicode, but many tools don't.
- Conversion of Unicode to [ASCII](https://en.wikipedia.org/wiki/ASCII) formatting is often necessary in data preprocessing.  

**Tasks**
0. [data.exercise.M.1.csv](https://github.com/cosc-526/cosc.526.home.page/blob/main/data.exercise.M.1.csv)  
1. Read this article on diacritics conversion (e.g., "ü" → "ue"); [transliteration](https://german.stackexchange.com/questions/4992/conversion-table-for-diacritics-e-g-%C3%BC-%E2%86%92-ue).  
2. Analyze and run code block with a dictionary matching Unicode character "keys" to their ASCII transliteration "value."
=> as a refresher, a dictionary is defined as mydict = { key:value }
3. For labeled code sections #3.1 to 3.9, explain succinctly what the code is accomplishing and whether you are or are not familiar with it.  
4. Create your inventory mechanism to store this, and more, code blocks.  

***More useful links***
- [1: replace](https://docs.python.org/3.6/library/stdtypes.html#str.replace), [2: file object methods](https://docs.python.org/3/tutorial/inputoutput.html#methods-of-file-objects),
"""

translit_dict = {
    "ä" : "ae",
    "ö" : "oe",
    "ü" : "ue",
    "Ä" : "Ae",
    "Ö" : "Oe",
    "Ü" : "Ue", 
    "ł" : "l",
    "ō" : "o",
}
#3.1
with open("data.exercise.M.1.csv", 'r', encoding='utf8') as csvfile:
    lines = csvfile.readlines()
#3.2
# Strip off the newline from the end of each line
lines = [line.rstrip() for line in lines]

#3.3   
# Split each line based on the delimiter (which, in this case, is the comma)
split_lines = [line.split(",") for line in lines]

#3.4
# Separate the header from the data
header = split_lines[0]
data_lines = split_lines[1:]
    
#3.5    
# Find "name" within the header
name_index = header.index("name")

#3.6
# Extract the names from the rows
unicode_names = [line[name_index] for line in data_lines]

#3.7
# Iterate over the names
translit_names = []
for unicode_name in unicode_names:
    # Perform the replacements in the translit_dict
    # HINT: ref [1]
    translit_name = unicode_name
    for key, value in translit_dict.items():
        translit_name = translit_name.replace(key, value)
    translit_names.append(translit_name)

#3.8
# Write out the names to a file named "data-ascii.txt"
# HINT: ref [2]
with open("data.exercise.M.1.ascii.txt", 'w') as outfile:
    for name in translit_names:
        outfile.write(name + "\n")
#3.9
# Verify that the names were converted and written out correctly
with open("data.exercise.M.1.ascii.txt", 'r') as infile:
    for line in infile:
        print(line.rstrip())

# Write your reflection here
#3.1
#3.2
#3.3
#3.4
#3.5
#3.6
#3.7
#3.8
#3.9

"""**`Expected Output`**
```
Richard Phillips Feynman
Shin'ichiro Tomonaga
Julian Schwinger
Rudolf Ludwig Moessbauer
Erwin Schroedinger
Paul Dirac
Maria Sklodowska-Curie
Pierre Curie
```

#### Task.3.solution

3.1 Primary file open that specifies the data encoding type.  
==>Selecting the wrong encoders may significantly alter outcomes!  
3.2 List comprehension is removing trailing whitespace putting outcomes into a new list.    
3.3 List comprehension splitting each line element by the delimiter.    
3.4 [0] is a form of **slicing**.  
=> In this example [0] is the header row, ie row number 0. 
=> mylist[0], an iterable data object, extracts 1st item in the list object.    
=> ex: mylist[1,2,3]; mylist[0] [out]=> 1   
==> slice [1:] indicates to get data from row.1 til rows are empty.  
3.5 Performs a find based on a name range vs a slice; [:1]=column_1  
==> Is also the answer to Task 2.3 in the exercise.M.1 section.  
3.6 List comprehension with line as user-defined name to travail and read all lines in .csv file  
3.7 Illustrates a **for** loop that swaps a matched dictionary items with its ASCII transliteration.   
3.8 Note the **'w'** in the open statement to create the outfile with a user defined name.  
==> \n is a carriage return   
3.9 The ASCII file read back in and displayed using print() function.

## **`assign.M.1.assignment.1`** - Data Mining with Covid Data

### **`Overview and Directions`**

1. Import and manipulate a .csv file  
2. Assess your Python Programming Skills  
3. Other assignments are more challenging; use this to assess your skills.
4. Prepare questions for a class discussion to help source additional tools. 
5. Perform tasks without assistance from clever sources.    

#### **`Desired outcomes`**  
- Experience Pandas dataframes to group, aggregate, find, sort, and calculate.  
- Perform calculations to find best country, rank, and total items processed. 
- Note: Pandas is reviewed in Module 2 and quality resources provided below.  

#### **`Additional resources`**  
- [Daniel Chen](https://github.com/chendaniely/) is a **generous** Pandas master.  
=> Purchase of his books is recommended; not a solicitation!    
- [Chen,D.,(2022). Pandas for everyone, 2nd.Ed.](https://www.amazon.com/Pandas-Everyone-Analysis-Addison-Wesley-Analytics/dp/0137891156/ref=sr_1_1?crid=T9BF3HU24YFL&keywords=pandas+for+everyone&qid=1685205022&sprefix=pandas+for+everyone%2Caps%2C203&sr=8-1)  
=> [groupby](https://github.com/chendaniely/2017-10-26-python_crash_course/blob/gh-pages/notebooks/07-groupby.ipynb) => [missing values](https://github.com/chendaniely/2017-10-26-python_crash_course/blob/gh-pages/notebooks/03-missing.ipynb) => [many more!](https://github.com/chendaniely/2017-10-26-python_crash_course/tree/gh-pages/notebooks)

### **`Task.0`**

#### **`Dataset`**
- COVID-19 variant [sequencing](https://www.cdc.gov/coronavirus/2019-ncov/variants/genomic-surveillance.html#:~:text=Scientists%20use%20a%20process%20called%20genomic%20sequencing%20to%20identify%20SARS,test%20positive%20for%20COVID%2D19) by countries.   
Data fields    
1. `location`: the country providing information.    
2. `date`: data entry date.  
3. `variant`: the COVID-19 variant for the entered record.  
4. `num_sequences`: the number of sequences **processed** by country, variant, and date.   
5. `num_sequences_total`: the number of sequences **available** by country, variant, and date.  
6. `perc_sequences`: the percentage of the available sequences processed (*out of 100*)  
`note:` each dataset row represents *one* variant by *one* country on *one* day.  

**Tasks**  
1. Locate and read dataset into a pandas.DataFrame called 'df' via  
a. A Kaggle API; use existing or acquire; [Kaggle.covid.dataset](https://www.kaggle.com/yamqwe/omicron-covid19-variant-daily-cases?select=covid-variants.csv)  
or  
b. Class github URL or another .csv method like [Matthes, Ch.16](https://github.com/cosc-526/cosc.526.home.page/blob/main/textbook.Python.crash.course.matthes.pdf)    
=> filename: **data.assignment.M.1.covid.data.csv**  
=>**consider** reading a Github data URL requires a path to **raw data**    
2. Display the DataFrame's first 5 rows.  
3. Display descriptive stats confirming: 100,416 data records.  
4. Round DataFrame to 1 decimal place!   

**Useful links**  
[Built-in Functions](https://docs.python.org/3/library/functions.html#built-in-functions)  
[pandas.DataFrame documentation](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html)
"""

## Enter solution here

"""#### **`Task.0 - Expected Outcome`**  
```
DataFrame header
  location  date        variant  num_sequences  perc_sequences  num_sequences_total
0   Angola  2020-07-06      Alpha              0             0.0   3
1   Angola  2020-07-06  B.1.1.277              0             0.0   3
2   Angola  2020-07-06  B.1.1.302              0             0.0   3
3   Angola  2020-07-06  B.1.1.519              0             0.0   3
4   Angola  2020-07-06    B.1.160              0             0.0   3

Dataframe descriptive statistics, rounded to tenths
       num_sequences  perc_sequences  num_sequences_total
count       100416.0        100416.0             100416.0
mean            72.0             6.0               1510.0
std           1669.0            22.0               8445.0
min              0.0            -0.0                  1.0
25%              0.0             0.0                 12.0
50%              0.0             0.0                 59.0
75%              0.0             0.0                394.0
max         142280.0           100.0             146170.0 
```

##### **`Task.0 Solution via Github`**
"""

#Task.0.solution
#=> Read Data w URL
import pandas as pd
url = "https://raw.githubusercontent.com/cosc-526/cosc.526.home.page/main/data.assignment.M.1.covid.data.csv?token=GHSAT0AAAAAACDFFWJJR2XX26CMBR5PFXS6ZDSPTDQ"
df = pd.read_csv(url)
round(df.describe(),1)

"""##### **`Task.0 Solution w kaggle API key`**
1. use this to learn API data grabs  
2. **hint** you may this code later in course  
"""

#=>Kaggle data API part I of II
""" if you don't have your kaggle.json in Files\root\kaggle folder
    you need to find this folder. see picture below. Only way this works!"""
!cp /content/drive/MyDrive/Colab Notebooks/kaggle.json ~/.kaggle/
import kaggle
kaggle.api.authenticate()             #authenticae your key
!chmod 600 /root/.kaggle/kaggle.json  #hide your key
print("==> api key connect success <==")
!kaggle datasets download -d gpreda/covid19-variants  #read the dataset
print("==> data import success <==")

#test is all packages installed
#!pip install kaggle,  #!mkdir ~/.kaggle)
#!pip freeze | grep kaggle
#!pip freeze | grep pandas
#!pip freeze | grep numpy
#!pip freeze | grep matplotlib

"""![g.kaggle.json.location.JPG](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEBIAEgAAD/4RDaRXhpZgAATU0AKgAAAAgABAE7AAIAAAAFAAAISodpAAQAAAABAAAIUJydAAEAAAAKAAAQyOocAAcAAAgMAAAAPgAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJCIEUAAAAFkAMAAgAAABQAABCekAQAAgAAABQAABCykpEAAgAAAAM3OQAAkpIAAgAAAAM3OQAA6hwABwAACAwAAAiSAAAAABzqAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAyMzowNToyNyAxODoyMzowNgAyMDIzOjA1OjI3IDE4OjIzOjA2AAAAQgBCACAARQAAAP/hCxdodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvADw/eHBhY2tldCBiZWdpbj0n77u/JyBpZD0nVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkJz8+DQo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIj48cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPjxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSJ1dWlkOmZhZjViZGQ1LWJhM2QtMTFkYS1hZDMxLWQzM2Q3NTE4MmYxYiIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIi8+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iPjx4bXA6Q3JlYXRlRGF0ZT4yMDIzLTA1LTI3VDE4OjIzOjA2Ljc4NjwveG1wOkNyZWF0ZURhdGU+PC9yZGY6RGVzY3JpcHRpb24+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iPjxkYzpjcmVhdG9yPjxyZGY6U2VxIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+PHJkZjpsaT5CQiBFPC9yZGY6bGk+PC9yZGY6U2VxPg0KCQkJPC9kYzpjcmVhdG9yPjwvcmRmOkRlc2NyaXB0aW9uPjwvcmRmOlJERj48L3g6eG1wbWV0YT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0ndyc/Pv/bAEMABwUFBgUEBwYFBggHBwgKEQsK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)"""

#=>Kaggle data API part I of II
import kaggle
# Load data into a pandas DataFrame
df = pd.read_csv('covid19-variants.zip')
# display a view of the imported data, function = pd.head()
print("------------------------------")
print("> dataframe fields w pd.head <")
print("------------------------------")
print(df.head())

# display descriptive statistics
print("------------------------------")
print("==> descriptive statistics <==")
print("------------------------------")
print(round(df.describe()),1)

"""### **`Task.1`** - Find uncommon variants

The U.S. experienced the COVID-19 `Alpha`, `Delta`, `Omicron`  

**Tasks**  
0. In whatever object you like, e.g. list, dataframe, etc  
1. Get unique variant items for category: **`US_and_other`**  
=> where variants == [US, `non_who`, `others`]  
2. Get unique variant items for category: **`nonUS_and_other`**  
=> where variants != [US, `non_who`, `others`]  
3. Print your chosen objects to display unique variant categories.  
4. Show a total unique count for each, and total for dataset,

**Useful links**   
- [len()](https://docs.python.org/3/library/functions.html#len)
- [list comprehension w Bro Code](https://www.youtube.com/watch?v=fcLDzKH_5XM)
"""

#=>Enter Your Solution

"""#### **`Task.1 - Expected Outcome`**  
```
note: organization of output can vary widely!  

['Alpha', 'Delta', 'Omicron', 'others', 'non_who']  

total US + other =  5

['B.1.1.277', 'B.1.1.302', 'B.1.1.519', 'B.1.160', 'B.1.177', 'B.1.221',  
 'B.1.258', 'B.1.367', 'B.1.620', 'Beta', 'Epsilon', 'Eta', 'Gamma', 'Iota',  
  'Kappa', 'Lambda', 'Mu', 'S:677H.Robin1', 'S:677P.Pelican']   
  
total nonUS+other =  19   

total unique variants =  24 
```

#### **`Task.1 solution`**
"""

#Task.1.solution - as a list
import pandas as pd

#1. Get unique variant items: US_and_other where variants == [US, on_who, others]
mylist_US_and_other =["Alpha", "Delta", "Omicron", "others", "non_who"]

#2. Get unique variant items: nonUS_and_other where variants != [US, on_who, others]
mylist_nonUS_and_other = []
mylist_all_variants = df["variant"].unique().tolist()

#use of list comprehension method
mylist_nonUS_and_other = ([x for x in mylist_all_variants \
          if x not in ["Alpha", "Delta", "Omicron", "others", "non_who"]])

print(mylist_US_and_other, "\n total US + other = ",len(mylist_US_and_other),"\n")
print(mylist_nonUS_and_other,"\n total nonUS+other = ",len(mylist_nonUS_and_other))
print("\n total unique variants = ", len(mylist_US_and_other)+len(mylist_nonUS_and_other))

#df_nonUS_and_other = pd.DataFrame ([x for x in mylist_all_variants if x not in ["Alpha", "Delta", "Omicron", "others", "non_who"]])

"""### **`Task.2`** - Find the most processed variant

**Tasks**  
1. Which variant of COVID-19 has the most sequences processed?  
2. Store and print the result in a string called **`variant_most_proc`**  

**Useful links**  
[pd.DataFrame.groupby](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html#pandas-dataframe-groupby), [pd.DataFrame.aggregate](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.aggregate.html#pandas-dataframe-aggregate)
"""

#=>Enter Your Solution

"""#### **`Task.2 - Expected Outcome`**  
```
Delta  
```

#### **`Task.2 - Solution`**
"""

#Task.2.solution
variant_most_proc = ""
df2 = df.groupby("variant").aggregate({"num_sequences": "sum"})
df2 = df2.sort_values("num_sequences", ascending=False)
variant_most_proc = df2.index[0]
print(variant_most_proc)

"""### **`Task.3`** - Find the best country at processing ALL variant sequences

**Tasks**  
1. Which country did the best processing **all** categories.    
2. Store the result in a string called **`best_proc_country`**  
3. The outcome is a single country.  
4. **consider** df.groupby("location").aggregate({"num_sequences": "sum", "num_sequences_total": "sum"})

**Useful links**  
[youtube: aggregate with groupby and .agg or .aggregate](https://www.youtube.com/watch?v=PNzlx3CjqAE)
"""

#=>Enter Your Solution

"""#### **`Task.3 - Expected Outcome`**
```
Total percent performed by country 

location                percent
Cyprus                  8.19
Hungary                 7.96
Egypt                   7.77
United Arab Emirates    7.58
Uruguay                 7.26
                        ... 
Seychelles              4.25
Fiji                    4.23
Slovakia                4.23
Brunei                  4.22
Vietnam                 4.18
Name: perc_sequences, Length: 121, dtype: float64 

the best country is =>  Cyprus
```

#### **`Task.3 - Solution`**
"""

best_proc_country = ""
### BEGIN SOLUTION
df3 = df.groupby("location").aggregate({"num_sequences": "sum", "num_sequences_total": "sum"})
df3["perc_sequences"] = round((df3["num_sequences"] / df3["num_sequences_total"]) * 100,2)
df4 = df3["perc_sequences"].sort_values(ascending=False)
print("Total percent performed by country \n \n",df4, "\n")
best_proc_country = df4.index[0]  #list is sorted so country in first position
print("the best country is => ",best_proc_country)
### END SOLUTION

"""### **`Task.4a`** - Find the best country at processing specific variant sequences

**Tasks**  
1. Which country is best at processing sequences for Alpha, Delta, and Omicron variants?    
2. Store and print the result in a string called **`best_proc_country_ADO`** 
3. The final output is a single country.  

**Useful links** 
- ibid
"""

#=>Enter Your Solution

"""#### **`Task.4a - Expected Outcome`**  
```
best_proc_country_ADO = Vietnam  
```

#### **`Task.4a - Solution`**
"""

best_proc_country_ado = ""
### BEGIN SOLUTION
df5 = df.loc[df["variant"].isin(["Alpha", "Delta", "Omicron"])]
df5 = df5.groupby("location").aggregate({"num_sequences": "sum", "num_sequences_total": "sum"})
df5["perc_sequences"] = (df5["num_sequences"] / df5["num_sequences_total"]) * 100
df5 = df5["perc_sequences"].sort_values(ascending=False)
best_proc_country_ADO = df5.index[0]
print(best_proc_country_ADO)
### END SOLUTION

"""### **`Task.4b`** - Find the United States ranking for processing Alpha, Delta, and Omicron

**Tasks**  
Given the outcome in 4a
1. Find the positional index value for the US ranking for processing sequences for Alpha, Delta, an Omicron variants.   
2. Store and print the ranking as an integer in a **us_ranking** variable.  
3. Ensure your ranking scale reflects a scale starting at 1.  
4. As a refresher, Python indexing starts at 0.  

**Useful links** 
- [enumerate](https://docs.python.org/3/library/functions.html#enumerate)
"""

#=>Enter Your Solution

"""#### **`Task.4b - Expected Outcome`**  
```
United States ranking = 57  
```

#### **`Task.4b.solution`**
"""

us_ranking = -1
country_rankings = df5.index.tolist()
us_ranking = country_rankings.index("United States") + 1
print("US ranking via .index method =",us_ranking)

#using enumerate  
for index, country in enumerate(country_rankings):
  if country == "United States":
    print("US ranking via enumerate = ", index+1)
    break

"""### **`Task.5`** - Train the trainee  
#### **`Write a work order memo to a junior data sciencist`**
=> final task for assignment.M.1

Data science isn't only about crafting clever solutions. Its also involves explaining what you did and writing what you need to help accomplish an analysis task.

In this scenario you are senior data scientist tasked with training a junior data scientist called "Jr." Jr. has quality skills but prefers specific rather than general task instructions.

Given the provided code blocks, that is what you need your junior analyst to create, generate a work order request with two to three more levels of detail than the **original instruction tasks.** enabling your staff to complete the task successfully. 

**Other specific Task.5 requirements**  
1. For each line of the code, explain in plain language the mechanics being performed.  
2. Plain language involves looking up both Pandas and Python methods to effectively explain code components. 
3. Considering the original instructions, generate a list of the "useful links" necessary to guide a novice coder to reverse engineer the solution provided.  

#### **`Task.x`** - Find the number of processed sequences per country on a specified date

--------------------
#### **`Original - Instruction Tasks`**  
---------------------
**Goal** -  Find the number of processed sequences per country on a specified date
**Part I of II**
1. Determine each country's total number of processed sequences for the Omicron variant on December 27, 2021.  
2. Output should include both country name and number of processed sequences.  
3. Sort the output from the high to low.  
4. Store the result as a list of tuples, with each tuple containing the country name first and number processed sequences second.  
5. Save and print the result in a variable called `total_omicron_2021`

**Useful links** 
- None  
- your assignment is to source and list them !
"""

#### **Write your work order here))

"""```
total_omicron_2021 = []
#5.1
df6 = df.set_index("location")
#5.2
df6 = df6.loc[df6["date"] == "2021-12-27"]
#5.3
df6 = df6.loc[df6["variant"] == "Omicron"]
#5.3
df6 = df6["num_sequences"]
#5.4
total_omicron_2021 = list(zip(df6.index, df6))
#5.5
df7 = pd.DataFrame(sorted(total_omicron_2021, key=lambda x: x[1], reverse=True))
print(df7)
---------------------
[out]
---------------------
0	                1
0	United Kingdom	52456
1	United States	  24681
2	Denmark	        3331
3	Germany	        1701
4	Israel	        1578
...	...	...
59	Vietnam	      1
60	Moldova	      0
61	Monaco	      0
62	Nepal	        0
63	South Korea 	0
64 rows × 2 columns
```

#### END - assignment.M.1
#### **Reference Only**  
#### DataFrame.groupby and positional calculations using pd.DataFrames.loc  

1. Determine the percentage of processed sequences for the Alpha, Delta, and Omicron variants in the US.  
2. Store the result as a dictionary where keys are variant names and values are percentages.  
3. Save the result in a variable called proc_seq_us.  

```
proc_seq_us = {}
### BEGIN SOLUTION
df2 = df.groupby(["location", "variant"]).aggregate({
    "num_sequences": "sum",
    "num_sequences_total": "sum",
})
df2["perc_sequences"] = (df2["num_sequences"] / df2["num_sequences_total"]) * 100
df2 = df2.loc[("United States", ["Alpha", "Delta", "Omicron"]), :].loc["United States"]
df2 = df2["perc_sequences"]
proc_seq_us = df2.to_dict()
print(proc_seq_us)
[out]
{'Alpha': 11.520951617373877, 'Delta': 63.76796208057254, 'Omicron': 1.370817855027461}
```
"""

total_omicron_2021 = []
#5.1
df6 = df.set_index("location")
#5.2
df6 = df6.loc[df6["date"] == "2021-12-27"]
#5.3
df6 = df6.loc[df6["variant"] == "Omicron"]
#5.3
df6 = df6["num_sequences"]
#5.4
total_omicron_2021 = list(zip(df6.index, df6))
#5.5
df7 = pd.DataFrame(sorted(total_omicron_2021, key=lambda x: x[1], reverse=True))
print(df7)
total_omicron_2021 = sorted(total_omicron_2021, key=lambda x: x[1], reverse=True)
print(total_omicron_2021)
"""
#[('United Kingdom', 52456), ('United States', 24681), ('Denmark', 3331),
 ('Germany', 1701), ('Israel', 1578), ('Australia', 1319), ('Switzerland', 514),
  ('France', 509), ('Italy', 486), ('Belgium', 464), ('Spain', 461), 
  ('Sweden', 434), ('Chile', 260), ('Netherlands', 254), ('Singapore', 249),
  ('Mexico', 240), ('Turkey', 202), ('India', 174), ('Brazil', 147),
   ('Botswana', 142), ('Indonesia', 128), ('Japan', 118), ('Portugal', 118),
    ('Argentina', 80), ('New Zealand', 63), ('South Africa', 61), 
    ('Lithuania', 50), ('Czechia', 49), ('Georgia', 46), ('Russia', 45), 
    ('Colombia', 37), ('Sri Lanka', 37), ('Hong Kong', 35), ('Malta', 34),
     ('Poland', 28), ('Ecuador', 26), ('Canada', 25), ('Jordan', 22), 
     ('Malawi', 21), ('Cambodia', 18), ('Norway', 17), ('Morocco', 15), 
     ('Senegal', 15), ('Costa Rica', 14), ('Pakistan', 11), ('Nigeria', 10),
      ('Peru', 10), ('Brunei', 8), ('Slovakia', 8), ('Trinidad and Tobago', 8),
       ('Maldives', 7), ('Zambia', 7), ('Thailand', 6), ('Malaysia', 5), 
       ('Bangladesh', 4), ('Romania', 3), ('Iran', 1), ('Oman', 1),
        ('Ukraine', 1), ('Vietnam', 1), ('Moldova', 0), ('Monaco', 0), 
        ('Nepal', 0), ('South Korea', 0)]
"""

#=>Enter Your Solution
proc_seq_us = {}
### BEGIN SOLUTION
df2 = df.groupby(["location", "variant"]).aggregate({
    "num_sequences": "sum",
    "num_sequences_total": "sum",
})
df2["perc_sequences"] = (df2["num_sequences"] / df2["num_sequences_total"]) * 100
df2 = df2.loc[("United States", ["Alpha", "Delta", "Omicron"]), :].loc["United States"]
df2 = df2["perc_sequences"]
proc_seq_us = df2.to_dict()
print(proc_seq_us)
### END SOLUTION
#[out]
#{'Alpha': 11.520951617373877, 'Delta': 63.76796208057254, 'Omicron': 1.370817855027461}

"""#### **`Task. - Expected Outcome`**  
```
#5.1
df6 = df.set_index("location")
#5.2
df6 = df6.loc[df6["date"] == "2021-12-27"]
#5.3
df6 = df6.loc[df6["variant"] == "Omicron"]
#5.3
df6 = df6["num_sequences"]
#5.4
total_omicron_2021 = list(zip(df6.index, df6))
#5.5
```

#### **`Task.5.solution`**

### Housekeeping, unmount drive
"""

from google.colab import drive
drive.flush_and_unmount()

"""# `end.M1`
-------------

# Tempalte Level.2 category: exercise or assignment
=> change this indent to ##

### **`Overview and Directions`**

* Practice importing and parsing information. 
* Focus on learning and solving versus coding perfectly.  
* Perform tasks without assistance from clever sources.
  
#### **`Desired outcomes`**  
- Experience open, read, and writing of external delimited files.  
- Navigate basic text mining preprocessing like white space stripping.  
- Refresh expereience with iterator, conditionals, and functions.  

#### **`Additional Resources`**  
- course

### **`Task.1`**  - level.3 title

Reading and p
- *.csv* files s  

**Tasks**  
0. [data.exercise.M.1.csv](h    
1. Generate a single value for the total number of rows of data.

**Useful links**  
- [Python.Crash.Course, Matthes](https://github.com/cosc-526/cosc.526.home.page/blob/main/textbook.Python.crash.course.matthes.pdf)
"""

#=>Enter Your Solution

"""**Task.1 Expected Ouput**
```
Number of rows of data: 8
Number of cols: 3
Average Age: 70.875
```

#### **`Task.1.solution`**
"""

#Task.1 solution
parse_delimited_file('data.exercise.M.1.csv')

"""### **`Task.2`** - level.3 title

Reading and p
- *.csv* files s  

**Tasks**  
0. [data.exercise.M.1.csv](h    
1. Generate a single value for the total number of rows of data.

**Useful links**  
- [Python.Crash.Course, Matthes](https://github.com/cosc-526/cosc.526.home.page/blob/main/textbook.Python.crash.course.matthes.pdf)
"""

#=>Enter Your Solution

"""**Task.2 Expected Ouput**
```
Number of rows of data: 8
Number of cols: 3
Average Age: 70.875
```

#### **`Task.2.solution`**
"""

#Task.1 solution
parse_delimited_file('data.exercise.M.1.csv')

"""# **`M2 - Data preprocessing`**

## **`exercise.M.2.exercise.1`**

## **`assignment.M.2`** - Titanic

### **`Overview and Directions`**

* Modify any code and write new code to solve the questions. 
* Save and submit work ONLY associated with this module.  
* https://github.com/cosc-526/cosc.526.home.page/blob/main/assign.M.1.assignment.1.covid.data.pdf  

#### **`Desired Outcomes`**
1. Import and manipulate a .csv file  
2. Assess your Python Programming Skills  
3. Other assignments are more challenging. Use this one to assess your skills.
4. Attempt to solve the problems without searching for online assistance.
5. Prepare resource questions for the class discussion to help source additional tools.  

#### **`Additional Resources`**
1. Import and mani

### **`Task.0`** Import and view dataframe head and descriptive statistics

data => COVID-19 sequences by different countries over time.    
1. `location`: the country for which the information is provided  
2. `date`: th. 
* [Kaggle](https://www.kaggle.com/yamqwe/omicron-covid19-variant-daily-cases?select=covid-variants.csv) home, use your kaggle API (or get one if you like), URL via class GitHub, or the .csv file.

* [Kaggle](https://www.kaggle.com/yamqwe/omicron-covid19-variant-daily-cases?select=covid-variants.csv) home, use your kaggle API (or get one if you like), URL via class GitHub, or the .csv file.
"""

## Enter solution here

"""#### **`Task.0 - Expected Outcome`**  """



"""##### **`Task.0 Solution`**  """

#=> Read Data w URL
#=> from a url into pandas or once loaded in notebook
import pandas as pd

url = "https://raw.githubusercontent.com/cosc-526/cosc.526.home.page/main/d.data.M.1.assignment.1.covid.data.csv"
df = pd.read_csv(url)
print("done")

"""Optional kaggle via API key"""

#=>Kaggle data API part I of II
from google.colab import drive
drive.mount('/content/drive') #mount drive and connect key
                              #copies you api from google colab folder
!cp /content/drive/MyDrive/Colab Notebooks/kaggle.json ~/.kaggle/
import kaggle                         #open library
kaggle.api.authenticate()             #authenticae your key
!chmod 600 /root/.kaggle/kaggle.json  #hide your key
print("==> api key connect success <==")
!kaggle datasets download -d gpreda/covid19-variants  #read the dataset
print("==> data import success <==")

#test is all packages installed
#!pip install kaggle,  #!mkdir ~/.kaggle)
#!pip freeze | grep kaggle
#!pip freeze | grep pandas
#!pip freeze | grep numpy
#!pip freeze | grep matplotlib

#=>Kaggle data API part I of II
import kaggle
# Load data into a pandas DataFrame
df = pd.read_csv('covid19-variants.zip')
# display a view of the imported data, function = pd.head()
print("------------------------------")
print("> dataframe fields w pd.head <")
print("------------------------------")
print(df.head())

# display descriptive statistics
print("------------------------------")
print("==> descriptive statistics <==")
print("------------------------------")
print(round(df.describe()),1)

"""# `end.M.2`
--------------

# **`M3 - Algorithms: Unsupervised`**

### **`Directions`**
* Modify any code and write new code to solve the questions. 
* Save and submit work ONLY associated with this module.

## **`exercise.M.3.exercise.1`**

# `end.M.3`
----------

# **`M4 - Algorithms: Supervised`**

### **`Directions`**
* Modify any code and write new code to solve the questions. 
* Save and submit work ONLY associated with this module.

## **`exercise.M.4.exercise.1`**

# `end.M.4`
----------

# **`M5 - Part I of III: Apache Spark`**

### **`Directions`**
* Modify any code and write new code to solve the questions. 
* Save and submit work ONLY associated with this module.

# `end.M5`
---------

# **`M6 - Part II of III: Apache Spark`**

### **`Directions`**
* Modify any code and write new code to solve the questions. 
* Save and submit work ONLY associated with this module.

## **`exercise.M.6.exercise.1`**

# `end.M6`
---------

# **`M7 - Part III of III: Apache Spark`**

### **`Directions`**
* Modify any code and write new code to solve the questions. 
* Save and submit work ONLY associated with this module.

## **`exercise.M.7.exercise.1`**

# `end.M.7`
-----------

# **`M8 - Data science interviewing`**

### **`Directions`**
* Modify any code and write new code to solve the questions. 
* Save and submit work ONLY associated with this module.

# `end.M.8`
-----------

# **`M9 - Recommender Systems`**

### **`Directions`**
* Modify any code and write new code to solve the questions. 
* Save and submit work ONLY associated with this module.

Brian.scratch pad.

# `end.M.9`
-----------

---------------

## Tempalte Level.2 category: exercise or assignment
=> this is a ## level template, no matter what happens on row aboce!

### **`Overview and Directions`**

* Practice importing and parsing information. 
* Focus on learning and solving versus coding perfectly.  
* Perform tasks without assistance from clever sources.
  
#### **`Desired outcomes`**  
- Experience open, read, and writing of external delimited files.  
- Navigate basic text mining preprocessing like white space stripping.  
- Refresh expereience with iterator, conditionals, and functions.  

#### **`Additional Resources`**  
- course

### **`Task.1`**  - level.3 title

Reading and p
- *.csv* files s  

**Tasks**  
0. [data.exercise.M.1.csv](h    
1. Generate a single value for the total number of rows of data.

**Useful links**  
- [Python.Crash.Course, Matthes](https://github.com/cosc-526/cosc.526.home.page/blob/main/textbook.Python.crash.course.matthes.pdf)
"""

#=>Enter Your Solution

"""**Task.1 Expected Ouput**
```
Number of rows of data: 8
Number of cols: 3
Average Age: 70.875
```

#### **`Task.1.solution`**
"""

#Task.1 solution
parse_delimited_file('data.exercise.M.1.csv')

"""### **`Task.2`** - level.3 title

Reading and p
- *.csv* files s  

**Tasks**  
0. [data.exercise.M.1.csv](h    
1. Generate a single value for the total number of rows of data.

**Useful links**  
- [Python.Crash.Course, Matthes](https://github.com/cosc-526/cosc.526.home.page/blob/main/textbook.Python.crash.course.matthes.pdf)
"""

#=>Enter Your Solution

"""**Task.2 Expected Ouput**
```
Number of rows of data: 8
Number of cols: 3
Average Age: 70.875
```

#### **`Task.2.solution`**
"""

#Task.1 solution
parse_delimited_file('data.exercise.M.1.csv')

"""# ===================================================

# prof.hogan's scratch pad

## picture
"""

![It doesn't matter what you write here](http://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/South_African_Giraffe,_head.jpg/877px-South_African_Giraffe,_head.jpg "Picture of a Giraffe)

"""## **`Nice header`**
```
nice block (three single quotes)
```
```
super nice giraffe!
```

formatting misc  
**`COSC.526 Introduction to Data Mining`**

![It doesn't matter what you write here](http://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/South_African_Giraffe,_head.jpg/877px-South_African_Giraffe,_head.jpg "Picture of a Giraffe")

## assignment.M2.technices
"""

#Technique => Drop missing data using pandas
import pandas as pd
import numpy as np

# Drop rows with missing data
df.dropna(axis=0, inplace=True)

# Drop columns with missing data
df.dropna(axis=1, inplace=True)

# Drop specific observations or variables
df.drop([1, 2], axis=0, inplace=True) # Drop rows 1 and 2
df.drop('VariableName', axis=1, inplace=True) # Drop column 'VariableName'

#Technique => imputing missing data using pandas and numpy
import pandas as pd
import numpy as np

# Forward-fill or backward-fill missing values
df.fillna(method='ffill', inplace=True) # Forward-fill
df.fillna(method='bfill', inplace=True) # Backward-fill

# Mean, median, or mode imputation
df.fillna(df.mean(), inplace=True) # Mean imputation
df.fillna(df.median(), inplace=True) # Median imputation
df.fillna(df.mode().iloc[0], inplace=True) # Mode imputation

# Interpolation
df.interpolate(inplace=True) # Default method is linear interpolatio
# Replace missing values in a specific column with a specific value
df['ColumnName'].fillna(0, inplace=True) # Replace missing values with 0

#Technique => Predicting missing data using Scikit-learn:
import pandas as pd
import numpy as np

# Split data into complete and incomplete sets
complete_data = df.dropna()
incomplete_data = df[df.isnull().any(axis=1)]

# Select features and target variable
X_complete = complete_data.drop('TargetVariable', axis=1)
y_complete = complete_data['TargetVariable']
X_incomplete = incomplete_data.drop('TargetVariable', axis=1)

# Train machine learning model
model = RandomForestRegressor()
model.fit(X_complete, y_complete)

# Predict missing values
y_pred = model.predict(X_incomplete)

# Fill in missing values in original data set
df.loc[df['TargetVariable'].isnull(), 'TargetVariable'] = y_pred

#Technique => Multiple imputation using Scikit-learn:
import pandas as pd
import numpy as np

# Create multiple imputed data sets
imputer = IterativeImputer(random_state=0)
imputed_data = imputer.fit_transform(df)

# Analyze each imputed data set separately
for i in range(imputed_data.shape[0]):
    data_set = imputed_data[i, :]
    # Perform analysis on data_set


#Handling missing data in time series using Pandas:

# Fill in missing values using linear interpolation
df['ColumnName'].interpolate(method='linear', inplace=True)

# Fill in missing values using spline interpolation
df['ColumnName'].interpolate(method='spline', order=3, inplace=True)

"""# prof.hogan - SVM graphic exploration

## Model.0 SVM - Affine space

### 0.0 svm affine hyperplane definition

In mathematics, an affine space is a geometric structure that generalizes the concept of Euclidean space. It is a set of points where the notion of linear combinations and parallelism is defined, but it does not have a fixed origin or coordinate system.

The term "affine" in affine space comes from the Latin word "affinis," which means "related" or "connected." An affine space captures the idea of a space that preserves certain geometric properties even after translations and parallel transformations.

In an affine space, any two points can be connected by a vector called a displacement vector. Affine combinations of points and vectors in an affine space are used to describe the relative positions and directions between points. These combinations allow for the definition of concepts such as lines, planes, and higher-dimensional analogs.

The term "affine" is used to emphasize the relationship and connection between points in the space, regardless of a specific origin or coordinate system. It characterizes a space where linear operations, such as vector addition and scalar multiplication, are defined but without the strict geometric properties, such as distances and angles, of Euclidean space.

### 0.1 SVM - affine space

User  
can you make a model and plot me an example?

Chatgpt  
Certainly! I can provide you with a simple example of an affine space and plot it for you. Let's consider a two-dimensional affine space.

In a two-dimensional affine space, we can define points using coordinates (x, y) and displacement vectors as (dx, dy). The affine combinations of points and displacement vectors are given by:

P + λV,

where P represents a point, V represents a displacement vector, and λ is a scalar parameter.

Let's consider three points in the affine space:  

P1 = (2, 3)  
P2 = (5, 1)  
P3 = (4, 6)  

To demonstrate affine combinations, we can take P1 as the base point and define a displacement vector V as (1, -1). We can vary the scalar parameter λ to obtain different points in the affine space.  

Here's an example code snippet in Python that demonstrates this:

-----------
When you run this code, it will generate a plot showing the base point P1, the displacement vector V, and three affine combinations of P1 and V.

You can experiment with different base points, displacement vectors, and scalar parameters to explore different affine spaces.
"""

import matplotlib.pyplot as plt

# Base point
P1 = [2, 3]

# Displacement vector
V = [1, -1]

# Scalars for affine combinations
lambdas = [0.2, 0.5, 0.8]

# Affine combinations of P1 and V
points = [list(map(sum, zip(P1, [l * v for v in V]))) for l in lambdas]

# Plotting the points
plt.plot(*zip(*points), 'ro')
plt.text(P1[0], P1[1], 'P1', ha='right')
plt.text(points[0][0], points[0][1], 'P1 + 0.2V', ha='right')
plt.text(points[1][0], points[1][1], 'P1 + 0.5V', ha='right')
plt.text(points[2][0], points[2][1], 'P1 + 0.8V', ha='left')

# Adding labels and gridlines
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.grid(True)

# Setting axis limits
plt.xlim(0, 5)
plt.ylim(0, 5)

# Displaying the plot
plt.show()

"""=end 0.1

### 0.2 Topic deepen with SVG and `Magic graphics`

This code combines the SVG code for rectangles with the affine space plot. The rectangles defined in the SVG code represent the base point, P1, and the three affine combinations P1 + 0.2V, P1 + 0.5V, and P1 + 0.8V. The resulting SVG image will show these rectangles along with the scatter plot of points in the affine space.

When you run this code in Jupyter Notebook or Colab, it will display the SVG image with the rectangles and the scatter plot of points. You can adjust the SVG code or customize the attributes to modify the appearance of the rectangles in the image.

User  
dont i want to see the plotting of the points in the svg code image?

ChatGPT  
I apologize for the confusion. The SVG code is primarily for vector graphics, and combining it with the plot would require additional steps beyond the scope of standard SVG capabilities.

However, I can provide an alternative approach where we generate the plot separately and then overlay it onto the SVG image using an image editing software. Here's an example that generates the plot and saves it as an image, which can be overlaid onto the SVG image:

After running this code, you will have an image file named affine_space_plot.png, which contains the scatter plot of points. You can then use an image editing software to overlay this plot onto the SVG image generated separately. In the image editing software, you can open the SVG image and place the plot image on top of it to create the desired visualization.

note: i combined to the plt.savefig were it asked to overalay
"""

from IPython.display import display, SVG
import matplotlib.pyplot as plt

# Base point
P1 = [2, 3]

# Displacement vector
V = [1, -1]

# Scalars for affine combinations
lambdas = [0.2, 0.5, 0.8]

# Affine combinations of P1 and V
points = [list(map(sum, zip(P1, [l * v for v in V]))) for l in lambdas]

# SVG code for a rectangle
svg_code = f'''
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8 8" width="300" height="300">
  <rect x="2" y="2" width="4" height="4" rx="0.5" style="fill:red; stroke:black; fill-opacity:0.7" />
  <rect x="{points[0][0] - 0.5}" y="{points[0][1] - 0.5}" width="4" height="4" rx="0.5" style="fill:white; stroke:black; fill-opacity:0.5" />
  <rect x="{points[1][0] - 0.5}" y="{points[1][1] - 0.5}" width="4" height="4" rx="0.5" style="fill:yellow; stroke:black; fill-opacity:0.5" />
  <rect x="{points[2][0] - 0.5}" y="{points[2][1] - 0.5}" width="4" height="4" rx="0.5" style="fill:blue; stroke:black; fill-opacity:0.5" />
</svg>
'''

# Display SVG image
display(SVG(svg_code))

# Plotting the points
plt.plot(*zip(*points), 'ro')
plt.text(P1[0], P1[1], 'P1', ha='right')
plt.text(points[0][0], points[0][1], 'P1 + 0.2V', ha='right')
plt.text(points[1][0], points[1][1], 'P1 + 0.5V', ha='right')
plt.text(points[2][0], points[2][1], 'P1 + 0.8V', ha='left')

# Adding labels and gridlines
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.grid(True)

# Setting axis limits
plt.xlim(0, 8)
plt.ylim(0, 8)

# Saving the plot as an image
plt.savefig('affine_space_plot.png')

# Displaying the plot
plt.show()

"""### 0.3 Confirmation of Interpreation

Q: i understand. so i can say with teh svg graphic i'm visualizign three hyperplanes, that is 3 affine subspaces or p-1  

ChatGPT
1. Yes, that's correct! In the context of the example we discussed earlier, you can interpret the rectangles in the SVG graphic as representing three hyperplanes or affine subspaces within the larger affine space.  

2. In a two-dimensional affine space, each of these rectangles can be considered as a one-dimensional affine subspace, as they are defined by a base point (P1) and a displacement vector (V) scaled by different scalar parameters (λ). These affine subspaces, or hyperplanes, are formed by the affine combinations P1 + λV.  

3. By visualizing these rectangles in the SVG graphic and considering their positions and orientations, you can gain insights into how the points in the affine space relate to each of these hyperplanes. It helps in understanding the concept of affine combinations and the structure of affine spaces.  

4. So, you can indeed interpret the rectangles in the SVG graphic as visualizations of three hyperplanes or affine subspaces within the two-dimensional affine space.

#### 0.3.1 revisualize of 0.2 learnings (redundant!)
"""

from IPython.display import display, SVG
import matplotlib.pyplot as plt

# Base point
P1 = [2, 3]

# Displacement vector
V = [1, -1]

# Scalars for affine combinations
lambdas = [0.2, 0.5, 0.8]

# Affine combinations of P1 and V
points = [list(map(sum, zip(P1, [l * v for v in V]))) for l in lambdas]

# SVG code for a rectangle
svg_code = f'''
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8 8" width="300" height="300">
  <rect x="2" y="2" width="4" height="4" rx="0.5" style="fill:red; stroke:black; fill-opacity:0.7" />
  <rect x="{points[0][0] - 0.5}" y="{points[0][1] - 0.5}" width="4" height="4" rx="0.5" style="fill:white; stroke:black; fill-opacity:0.5" />
  <rect x="{points[1][0] - 0.5}" y="{points[1][1] - 0.5}" width="4" height="4" rx="0.5" style="fill:yellow; stroke:black; fill-opacity:0.5" />
  <rect x="{points[2][0] - 0.5}" y="{points[2][1] - 0.5}" width="4" height="4" rx="0.5" style="fill:blue; stroke:black; fill-opacity:0.5" />
</svg>
'''

# Display SVG image
display(SVG(svg_code))

# Plotting the points
plt.plot(*zip(*points), 'ro')
plt.text(P1[0], P1[1], 'P1', ha='right')
plt.text(points[0][0], points[0][1], 'P1 + 0.2V', ha='right')
plt.text(points[1][0], points[1][1], 'P1 + 0.5V', ha='right')
plt.text(points[2][0], points[2][1], 'P1 + 0.8V', ha='left')

# Adding labels and gridlines
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.grid(True)

# Setting axis limits
plt.xlim(0, 8)
plt.ylim(0, 8)

# Saving the plot as an image
plt.savefig('affine_space_plot.png')

# Displaying the plot
plt.show()

"""### 0.4 Extend confirmation to 3 classes of fruit

User 
- to help me connect the dots, how about a simple example of what these features of space could be? can we use the example of apples, oranges, and bananas? i think this is what you have told me but if wrong it is me not you  

ChatGPT  
- Certainly! We can use the example of apples, oranges, and bananas to illustrate the concept of affine spaces and hyperplanes. Let's consider a two-dimensional space where the x-axis represents the sweetness of a fruit and the y-axis represents the acidity of a fruit.

In this space, we can define three points:  

1. Point A: (sweetness = 3, acidity = 4) representing an apple.  
2. Point B: (sweetness = 6, acidity = 2) representing an orange.  
3. Point C: (sweetness = 5, acidity = 6) representing a banana.  

Now, let's choose Point A (apple) as our base point in the affine space. We can define a displacement vector V that represents the difference between an orange and an apple. In this case, V = (6 - 3, 2 - 4) = (3, -2).  

- We can create three affine combinations of the base point (A) and the displacement vector (V) using different scalar parameters:  

1. A + 0.2V: (3, 4) + 0.2 * (3, -2) = (3.6, 3.6)  
2. A + 0.5V: (3, 4) + 0.5 * (3, -2) = (4.5, 3.0)  
3. A + 0.8V: (3, 4) + 0.8 * (3, -2) = (5.4, 2.4)  

- These three points represent affine combinations of the apple (A) and the difference between an orange and an apple (V). They lie on a hyperplane within the affine space.  

In the context of fruit, this hyperplane can be interpreted as a linear relationship between sweetness and acidity that connects the apple (A) and the orange (B). The points on this hyperplane represent fruit that shares characteristics between an apple and an orange in terms of sweetness and acidity.  

- Similarly, you can visualize another hyperplane connecting the apple (A) and the banana (C) using the displacement vector between them. The affine combinations on this hyperplane would represent fruit with characteristics intermediate to an apple and a banana.  

- By using this example, we can see how affine spaces and hyperplanes allow us to visualize and explore relationships between different objects or entities based on their attributes or features.

User   
this is a remarkable learning experience, thank you!  
ChatGPT  
- You're very welcome! I'm glad to hear that you found this learning experience remarkable. I'm here to help and provide information on a wide range of topics. If you have any more questions or need further assistance, feel free to ask. Happy learning!
----

### 0.5 now making apples, organzes, bananeas

- i dont want to tax your mellon too much, but I am thinking it wuld be super incredible to extend this svg example and also include a visualization of a two-dimensional subspace in effect visulizing your example one step back of sweetness to acidity. is thsi acheivable without heavy code lifting?

chatgpt  
- In this modified SVG code, we've added two line segments to represent the two-dimensional subspace connecting the apple, orange, and banana. The line segment connecting the apple (red rectangle) and the orange (orange rectangle) represents the relationship between sweetness and acidity for those fruits. Similarly, the line segment connecting the apple and the banana (yellow rectangle) represents their relationship.

- When you run this code in Jupyter Notebook or Colab, it will display the updated SVG image with the rectangles representing the fruits and the line segments representing the two-dimensional subspace. You can adjust the SVG code or customize the attributes to modify the appearance of the rectangles and the line segments as per your preference.
"""

from IPython.display import display, SVG

# SVG code for rectangles representing fruits
svg_code = '''
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10" width="400" height="400">
  <!-- Rectangle for apple -->
  <rect x="3" y="4" width="0.5" height="0.5" style="fill:red; stroke:red; fill-opacity:0.7" />
  <!-- Rectangle for orange -->
  <rect x="6" y="2" width="0.5" height="0.5" style="fill:orange; stroke:orange; fill-opacity:0.7" />
  <!-- Rectangle for banana -->
  <rect x="5" y="6" width="0.5" height="0.5" style="fill:yellow; stroke:yellow; fill-opacity:0.7" />
  
  <!-- Two-dimensional subspace visualization -->
  <!-- Line segment connecting apple and orange -->
  <line x1="3.25" y1="4.25" x2="6.25" y2="2.25" style="stroke:blue; stroke-width:0.1" />
  <!-- Line segment connecting apple and banana -->
  <line x1="3.25" y1="4.25" x2="5.25" y2="6.25" style="stroke:blue; stroke-width:0.1" />
</svg>
'''

# Display SVG image
display(SVG(svg_code))

"""### 0.5.1 What new comparison means

User  
so if i put the first image on the left and this new on the right I would be able to say the 1st svg image is like the layering of three different fruit spaces but in the second image we are now visualizing sweetness and acidity as a blue line amongst the three fruits? 
- Using the phrase "poor man perspective" in the seond image it basically says 2 fruits are more similar on 2 planes with each other but two other fruits are essentially not linearly seperatable. thank you for improving on the quality of my interpretation  

ChatGPT  
- You're absolutely correct! By placing the first SVG image on the left and the modified SVG image on the right, you can visually represent the different perspectives and relationships within the fruit space.

- The first SVG image, with the rectangles representing the fruits and the affine combinations, shows how the three fruits (apple, orange, and banana) are related in terms of their sweetness and acidity. Each rectangle represents a fruit, and the affine combinations represent points that lie on hyperplanes connecting the fruits.

- The second SVG image, with the rectangles and the blue line segments representing the two-dimensional subspace, provides a different perspective on the relationship between sweetness and acidity among the fruits. The blue line segments represent the two-dimensional subspace or relationship between sweetness and acidity, and they connect the fruits in a visual way.

- By juxtaposing these two images, you can observe that the first image showcases the fruit spaces and their affine combinations, whereas the second image focuses on the relationship between sweetness and acidity through a two-dimensional subspace. It indeed highlights how some fruits may be more similar or linearly separable in this particular perspective.  

ChatGPT  
Your interpretation of the second image as a "poor man's perspective" is quite accurate. It illustrates that certain fruits may exhibit similar trends or relationships in terms of sweetness and acidity, while others may not be as easily separable in this particular context.  

- I'm glad to hear that the improved interpretation and the visual representations have been helpful to you. If you have any further questions or need additional assistance, feel free to ask!

### 0.6 New Idea - compare the 2 images togehter

User  
thats great! now made me think of this. 
- i tool the last piece of code and change the colors to match the fruit, red, orange, and yellow. i think it still stands form the poor man perspective that an organe and a banana are not related in terms of sweetness and acidity if the values you provided for them are represent these fruits

ChatGPT  
That's a great observation! If you changed the colors in the SVG code to match the colors of the fruits, representing the apple as red, the orange as orange, and the banana as yellow, it would still reflect the "poor man perspective" that an orange and a banana are not directly related in terms of sweetness and acidity.

- In the modified SVG code, the line segment connecting the apple (red rectangle) and the orange (orange rectangle) represents their relationship in terms of sweetness and acidity. It suggests that there may be some similarity or trend between these two fruits in that specific context.

- On the other hand, the line segment connecting the apple (red rectangle) and the banana (yellow rectangle) represents their relationship. Since the colors of the orange and the banana are distinct and the line segments don't connect them directly, it reinforces the notion that they may not be linearly related or easily separable in terms of sweetness and acidity.

- By visually representing the fruits with their corresponding colors and observing the line segments, one can still interpret that the poor man's perspective aligns with the idea that certain fruits (e.g., apple and orange) may have more similarity in terms of sweetness and acidity, while others (e.g., orange and banana) may not exhibit a direct relationship.

- I appreciate your attention to detail and the thoughtful interpretation. If you have any more questions or need further clarification, feel free to ask!

chatgpt  
Yes, you have correctly connected the dots and made the necessary modifications to the SVG code. The code you provided will display the SVG image with the rectangles representing the fruits (apple, orange, and banana) in their respective colors (red, orange, and yellow). The line segments representing the two-dimensional subspace connecting the fruits are still depicted in blue.

- When you run this code in Jupyter Notebook or Colab, it will render the SVG image with the updated colors. The apple will appear as a red rectangle, the orange as an orange rectangle, and the banana as a yellow rectangle. The line segments connecting the fruits will remain blue, illustrating the two-dimensional subspace or relationship between sweetness and acidity.

- You can now observe the visual representation of the fruits and their relationships based on their colors. If you have any further questions or need additional assistance, please let me know!

### 0.7 now create 300 fruit

User  
so we were to extend this analogy to 3 buckets of 100 fruit where one is different apples, another is different banana types, and the final is different oranges, i would then have three hundred samples with different scores for sweetness and acidity. 
- this type view would then be aggregated and probably visualized in a different library package like plotpy?

ChatGPT  
Yes, if you were to extend the analogy to three buckets of 100 fruits each, representing different types of apples, bananas, and oranges, you would have a total of 300 samples with different scores for sweetness and acidity.

- To analyze and visualize this dataset, you can aggregate the data and use a different library package like Plotly, which provides interactive and customizable data visualization capabilities.

- You can organize your data in a tabular format, where each row represents a fruit sample and each column represents a variable (e.g., sweetness, acidity). You can then use Plotly to create various visualizations such as scatter plots, bar charts, or heatmaps to explore the relationships between sweetness, acidity, and different fruit types.

- For example, you could create a scatter plot where the x-axis represents sweetness, the y-axis represents acidity, and each data point represents a fruit sample. You can assign different colors or markers to represent different fruit types (apples, bananas, oranges) within the scatter plot.

- Additionally, you can leverage the interactive features of Plotly to add tooltips, hover effects, or zooming capabilities to explore the data more interactively. Plotly also supports annotations, labels, and legends, allowing you to add context and additional information to your visualizations.

- By using Plotly or other data visualization libraries, you can gain deeper insights into the relationships between sweetness, acidity, and different fruit types, and effectively communicate your findings to others.

- Remember to preprocess and aggregate your data appropriately before visualizing it to ensure meaningful and accurate representations.

User  
well i would use 2 lognormal distributions, one for sweetness and the other acidity with a mean of 4.67 for sweetness lognormal and 4 for acidity lognormal. 
- I would allow the standard devition to be 2.25 of the means (i didn't calculate this jsut giving the st.dev table value). 
- Then I would simply use the same distributions to genearte the 3 classes of fruit data with labels, apple, orange, and fruit.
- finally, run and svm algorithm and generate the visualization in plotly

chatgpt  
Thank you for providing the details for generating the dataset. I will create a sample dataset with two lognormal distributions representing sweetness and acidity, and then use those distributions to generate three classes of fruit data (apple, orange, and banana) with labels.   
- Finally, I will assist you in running an SVM algorithm and visualizing the results using Plotly.  

- Here's the Python code to generate the dataset, run the SVM algorithm, and visualize the results using Plotly:

- This code uses the NumPy library to generate random numbers from lognormal distributions, the pandas library to create a DataFrame, the scikit-learn library to train the SVM classifier, and the Plotly Express library to create the scatter plot with decision boundaries.

- Reduce the size of the dataset: Instead of generating 300 samples, you can try generating a smaller number of samples, such as 100 or 200, to see if it helps avoid running out of memory.

- Use a more memory-efficient algorithm: SVM with a linear kernel is generally memory-efficient, but if you still encounter memory issues, you can try using algorithms that are specifically designed for large datasets, such as stochastic gradient descent (SGD) or kernel approximation methods like Nystroem or random Fourier features.

- Use a cloud-based environment: As you mentioned, Colab Pro offers access to high-RAM runtimes, which can provide more memory to run your code without crashing. Alternatively, you can consider using other cloud-based platforms like Kaggle or AWS (Amazon Web Services) to run your code on more powerful machines with higher memory capacity.
"""

import numpy as np
import pandas as pd
from sklearn.svm import SVC
import plotly.express as px

# Set random seed for reproducibility
np.random.seed(42)

# Generate sweetness and acidity data using lognormal distributions
num_samples = 100  #300 wont run
mean_sweetness = 4.67
mean_acidity = 4.0
std_dev = 2.25

sweetness = np.random.lognormal(mean=np.log(mean_sweetness), sigma=std_dev, size=num_samples)
acidity = np.random.lognormal(mean=np.log(mean_acidity), sigma=std_dev, size=num_samples)

# Generate fruit labels
labels = np.repeat(['Apple', 'Orange', 'Banana'], num_samples // 3)

# Ensure all arrays have the same length
min_length = min(len(sweetness), len(acidity), len(labels))
sweetness = sweetness[:min_length]
acidity = acidity[:min_length]
labels = labels[:min_length]

# Create a DataFrame with the generated data
data = pd.DataFrame({'Sweetness': sweetness, 'Acidity': acidity, 'Fruit': labels})

# Split the data into features and target
X = data[['Sweetness', 'Acidity']]
y = data['Fruit']

# Train an SVM classifier
svm = SVC(kernel='linear')
svm.fit(X, y)

# Generate predictions for the entire feature space
x_min, x_max = X['Sweetness'].min() - 1, X['Sweetness'].max() + 1
y_min, y_max = X['Acidity'].min() - 1, X['Acidity'].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1), np.arange(y_min, y_max, 0.1))
Z = svm.predict(np.c_[xx.ravel(), yy.ravel()])
Z = Z.reshape(xx.shape)

# Create a scatter plot of the data with decision boundaries
fig = px.scatter(data, x='Sweetness', y='Acidity', color='Fruit')
fig.update_traces(marker=dict(size=8))
fig.add_contour(x=np.arange(x_min, x_max, 0.1), y=np.arange(y_min, y_max, 0.1), z=Z,
                colorscale='Viridis', opacity=0.3, showscale=False)

# Display the plot
fig.show()

import plotly.express as px

# Create a scatter plot
fig = px.scatter(data, x='Sweetness', y='Acidity', color='Fruit')

# Add layout
fig.update_layout(
    title="Fruit Data Visualization",
    xaxis=dict(title="Sweetness"),
    yaxis=dict(title="Acidity"),
    showlegend=True
)

# Display the plot
fig.show()

"""Chatgpt  
Here, we are using your trained SVM model svm to predict the classes for the meshgrid points. 
- The np.c_[xx.ravel(), yy.ravel()] creates a 2D array by flattening the xx and yy meshgrid points and concatenating them column-wise.  
- The predictions are then reshaped to match the shape of the meshgrid (xx.shape).  
- Make sure you have trained your SVM model (svm) before running this code.

User  
> "when you wrote "ere, we are using your trained SVM model svm to predict the classes for the meshgrid points. The np.c_[xx.ravel(), yy.ravel()] creates a 2D array by flattening the xx and yy meshgrid points and concatenating them column-wise. The predictions are then reshaped to match the shape of the meshgrid (xx.shape)."

- this is the kind of explanation that comes with experience, book reading, and so forth. i don't have the manual or refernce to ahve figured out what xx.shape was doing. that's incredibile!

ChatGPT
> Thank you for your kind words! I'm glad the explanation was helpful to you. Understanding the code and its underlying concepts often requires some experience and familiarity with the libraries and tools being used.

> In this case, xx.shape represents the shape (dimensions) of the meshgrid xx. The meshgrid is created to generate a grid of points in the x-axis and y-axis ranges defined by your data. The shape of the meshgrid determines the dimensions of the resulting predictions, and reshaping the predictions to match the meshgrid shape allows them to be plotted correctly.

> As you gain more experience and work with different tools and libraries, you'll become more comfortable with interpreting code and understanding how different components interact. Keep exploring and learning, and don't hesitate to ask questions along the way. I'm here to help!

As an AI language model, I don't have direct control over the code repository or the ability to update it. However, the code I provided should still work correctly without specifying the decision_function_shape parameter. The default value of decision_function_shape is 'ovr', which stands for "one-vs-rest" and is the recommended setting.

If you specifically need to use the 'ovo' (one-vs-one) decision function shape, you can include the decision_function_shape='ovo' parameter when creating the SVC object. However, please note that the decision function shape affects the multi-class strategy and not the visualization of decision boundaries.

The 'color' property is a color and may be specified as:
      - A hex string (e.g. '#ff0000')
      - An rgb/rgba string (e.g. 'rgb(255,0,0)')
      - An hsl/hsla string (e.g. 'hsl(0,100%,50%)')
      - An hsv/hsva string (e.g. 'hsv(0,100%,100%)')
      - A named CSS color:
            aliceblue, antiquewhite, aqua, aquamarine, azure,
            beige, bisque, black, blanchedalmond, blue,
            blueviolet, brown, burlywood, cadetblue,
            chartreuse, chocolate, coral, cornflowerblue,
            cornsilk, crimson, cyan, darkblue, darkcyan,
            darkgoldenrod, darkgray, darkgrey, darkgreen,
            darkkhaki, darkmagenta, darkolivegreen, darkorange,
            darkorchid, darkred, darksalmon, darkseagreen,
            darkslateblue, darkslategray, darkslategrey,
            darkturquoise, darkviolet, deeppink, deepskyblue,
            dimgray, dimgrey, dodgerblue, firebrick,
            floralwhite, forestgreen, fuchsia, gainsboro,
            ghostwhite, gold, goldenrod, gray, grey, green,
            greenyellow, honeydew, hotpink, indianred, indigo,
            ivory, khaki, lavender, lavenderblush, lawngreen,
            lemonchiffon, lightblue, lightcoral, lightcyan,
            lightgoldenrodyellow, lightgray, lightgrey,
            lightgreen, lightpink, lightsalmon, lightseagreen,
            lightskyblue, lightslategray, lightslategrey,
            lightsteelblue, lightyellow, lime, limegreen,
            linen, magenta, maroon, mediumaquamarine,
            mediumblue, mediumorchid, mediumpurple,
            mediumseagreen, mediumslateblue, mediumspringgreen,
            mediumturquoise, mediumvioletred, midnightblue,
            mintcream, mistyrose, moccasin, navajowhite, navy,
            oldlace, olive, olivedrab, orange, orangered,
            orchid, palegoldenrod, palegreen, paleturquoise,
            palevioletred, papayawhip, peachpuff, peru, pink,
            plum, powderblue, purple, red, rosybrown,
            royalblue, rebeccapurple, saddlebrown, salmon,
            sandybrown, seagreen, seashell, sienna, silver,
            skyblue, slateblue, slategray, slategrey, snow,
            springgreen, steelblue, tan, teal, thistle, tomato,
            turquoise, violet, wheat, white, whitesmoke,
            yellow, yellowgreen
"""

import numpy as np
import pandas as pd
import plotly.graph_objects as go
from sklearn.svm import SVC

import numpy as np
import pandas as pd
import plotly.graph_objects as go
from sklearn.svm import SVC

# Set random seed for reproducibility
np.random.seed(42)

# Generate sweetness and acidity data using lognormal distributions
num_samples = 80
mean_sweetness = 4.67
mean_acidity = 4.0
std_dev = 2.25

sweetness = np.random.lognormal(mean=np.log(mean_sweetness), sigma=std_dev, size=num_samples)
acidity = np.random.lognormal(mean=np.log(mean_acidity), sigma=std_dev, size=num_samples)

# Generate fruit labels
labels = np.repeat(['Apple', 'Orange', 'Banana'], num_samples // 3)

# Ensure all arrays have the same length
min_length = min(len(sweetness), len(acidity), len(labels))
sweetness = sweetness[:min_length]
acidity = acidity[:min_length]
labels = labels[:min_length]

# Create a DataFrame with the generated data
data = pd.DataFrame({'Sweetness': sweetness, 'Acidity': acidity, 'Fruit': labels}, columns=['Sweetness', 'Acidity', 'Fruit'])

# Split the data into features and target
#feature_names = ['Sweetness', 'Acidity']
#X = data[feature_names]
X = data[['Sweetness', 'Acidity']]
y = data['Fruit']

# Train an SVM classifier
svm = SVC(kernel='linear')
svm.fit(X, y)

# Generate predictions for the entire feature space
x_min, x_max = X['Sweetness'].min() - 1, X['Sweetness'].max() + 1
y_min, y_max = X['Acidity'].min() - 1, X['Acidity'].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1), np.arange(y_min, y_max, 0.1))
Z = svm.predict(np.c_[xx.ravel(), yy.ravel()])
Z = Z.reshape(xx.shape)

# Create a scatter plot of the data with decision boundaries
fig = go.Figure()

# Add the scatter plot
fig.add_trace(go.Scatter(
    x=data['Sweetness'],
    y=data['Acidity'],
    mode='markers',
    marker=dict(color=pd.factorize(data['Fruit'])[0], colorscale='Viridis', size=8),
    name='Fruit'
))

# Add the decision boundaries
fig.add_trace(go.Contour(
    x=np.arange(x_min, x_max, 0.1),
    y=np.arange(y_min, y_max, 0.1),
    z=Z,
    colorscale='Viridis',
    opacity=0.3,
    showscale=False,
    name='Decision Boundary'
))

# Set the layout
fig.update_layout(
    title="SVM with Hyperplane Margins",
    xaxis=dict(title="Sweetness"),
    yaxis=dict(title="Acidity"),
    showlegend=True
)

# Display the plot
fig.show()

"""# why SVG grapics

history of SVG. it seems to be an amazing package full of specialized visualziation programming. who and why was it built for. Why would a person want to even consider becomgin moderately proficient in it?
ChatGPT
Scalable Vector Graphics (SVG) is indeed a powerful and versatile technology for creating vector-based graphics and animations on the web. It was developed by the World Wide Web Consortium (W3C), a standards organization, with the goal of providing a standardized format for describing two-dimensional vector graphics on the web.

SVG was first introduced as a W3C recommendation in September 2001, although its roots can be traced back to the early days of the web when vector-based graphics were gaining popularity. It was designed to address the limitations of other image formats, such as raster graphics (e.g., JPEG, PNG), which are resolution-dependent and may lose quality when scaled or resized.

Here are a few reasons why someone might consider becoming moderately proficient in SVG:

Scalability: SVG graphics are resolution-independent, meaning they can be scaled up or down without any loss of quality. This makes SVG ideal for creating graphics that need to be displayed across different devices and screen sizes.

Interactivity: SVG supports a wide range of interactive features, such as event handling, animations, and scripting using JavaScript. This enables the creation of dynamic and interactive visualizations on the web.

Accessibility: SVG is accessible to assistive technologies and screen readers, making it suitable for creating inclusive web experiences. It supports alternative text descriptions and can be styled for better readability and contrast.

Searchability and SEO: Since SVG is based on XML, the content within an SVG file can be indexed by search engines. This can be advantageous when creating content that needs to be discovered and indexed by search engines.

Integration with HTML and CSS: SVG seamlessly integrates with HTML and CSS, allowing for easy incorporation of interactive graphics into existing web pages. It can be embedded directly within an HTML document or referenced externally.

Vector editing and manipulation: SVG files can be edited and manipulated using various software tools, both graphical and code-based. This provides flexibility in creating, modifying, and customizing vector graphics.

Widely supported: SVG is supported by all major web browsers, making it a reliable and widely adopted technology for web-based graphics.

By becoming moderately proficient in SVG, individuals can unlock the potential to create visually compelling, interactive, and scalable graphics for the web. It offers a range of possibilities for data visualizations, infographics, iconography, user interfaces, and more.

Keep in mind that while SVG is powerful, it may require some learning and practice to fully harness its capabilities. However, there are many resources available online, including documentation, tutorials, and examples, to help you get started and advance your skills in working with SVG.

I hope this overview helps shed light on why SVG is a valuable technology and why one might consider delving into it. If you have any further questions, feel free to ask!
"""

A:
# Create a DataFrame with the generated data
data = pd.DataFrame({'Sweetness': sweetness, 'Acidity': acidity, 'Fruit': labels})
# Split the data into features and target
X = data[['Sweetness', 'Acidity']]
y = data['Fruit']

B:
# Create a DataFrame with the generated data
data = pd.DataFrame({'Sweetness': sweetness, 'Acidity': acidity, 'Fruit': labels}, columns=['Sweetness', 'Acidity', 'Fruit'])
# Split the data into features and target
feature_names = ['Sweetness', 'Acidity']
X = data[feature_names]

import pandas as pd

myobject= [1,'M2.5',(2+0j)]
#--------------

mytuple = tuple(myobject)
print(mytuple,type(mytuple))
#[out] (1, 'M2.5', (2+0j)) <class 'tuple'>
#--------------

mylist = list(myobject)
print(mylist,type(mylist))
#[out] [1, 'M2.5', (2+0j)] <class 'list'>
#--------------

mydict = {i: key for i, key in enumerate(myobject)}
print(mydict, type(mydict))
#[out] {0: 1, 1: 'M2.5', 2: (2+0j)} <class 'dict'>
#--------------

myset = set(myobject)
print(myset,type(myset))
#[out] {1, (2+0j), 'M2.5'} <class 'set'>
#--------------

import pandas as pd
mydf = pd.DataFrame(myobject)
print(mydf,type(mydf))
#[out]
#         0
# 0       1
# 1    M2.5
# 2  (2+0j) <class 'pandas.core.frame.DataFrame'>
#--------------

Marsh = True
bool(mellow)
Marsh != mellow
print(mellow, type(mellow))
#[out] False <class 'bool'>
#--------------

myrange = range(-21,0,7)
for i in myrange:
  print(i)
#[out]
# -21
# -14
# -7
#--------------

mybytes = bytes([0x0A])
print(mybytes,type(mybytes))
#[out] b'\n' <class 'bytes'>
#--------------

mybytes = bytes([0x0A])
print(mybytes,type(mybytes))
#[out] b'\n' <class 'bytes'>

x = int(bh)
bool(bh)
print(bh)
type(bh)



"""## does this work

> Import, inspect data  
>> df.describe(), miss, na, null  
>>> boxplots, pairplot, sns, scatterplots  
>>>> address outliers & correlations  
>>>>> calc new variables  
>>>>>> select features  
>>>>>> OLS, MLR, R, R^2  


>>> iterate OLS, MLR  
>>>> final features select  
>>> eval. train\test outcomes  
>> confusion matrix  
> recommendations  
"""

# M.1 LMS quiz answers
print("----start-------")
import pandas as pd
myobject= [1,'M2.5',(2+0j)]
print(tuple(myobject))
print("--------------")
print(list(myobject))
print("--------------")
print({i: key for i, key in enumerate(myobject)})
print("--------------")
print(set(myobject))
print("--------------")
print(pd.DataFrame(myobject))
print("--------------")
Marsh=True
mellow=None
print(Marsh != bool(mellow))
print("--------------")
print([i for i in range(-21, 0, 7)])
print(bytes([0x0A]))
print("-----end-------")